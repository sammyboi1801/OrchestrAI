from langchain_experimental.graph_transformers.llm import system_prompt
from pydantic import BaseModel, Field
from typing import Annotated, Sequence, List, Literal, Optional
from langgraph.types import Command
from langgraph.graph import StateGraph, START, END, MessagesState
from langchain_core.messages import HumanMessage
from langchain_anthropic import ChatAnthropic
from langchain_google_genai import ChatGoogleGenerativeAI
from datetime import datetime

current_time = datetime.now()

class Orchestrator(BaseModel):
    content: str = Field(
        description="The complete, structured response generated by the orchestrator before passing it "
                    "to the supervisor for validation. This should include a clear step-by-step blueprint "
                    "of all actions taken, agents involved, and tools or APIs used. Each step must explain "
                    "what was done, why it was necessary, and what output or information was obtained. "
                    "The goal is to provide full traceability and justification so the supervisor can verify "
                    "the correctness, efficiency, and completeness of the reasoning process before delivering "
                    "the final response to the user. It can be empty for the intermediate steps but needs to "
                    "have content before passing it to the supervisor."
    )
    next: Literal["general", "researcher", "coder", "supervisor", "rag"] = Field(
        description="Determines which specialist AI agent to route control to next in the sequence:"
                    "'enhancer' when user input requires clarification, expansion or refinement,"
                    "'researcher' when additional facts, context, or data collection is necessary,"
                    "'coder' when implementation, computation, or technical problem-solving is required."
                    "'supervisor' when agent is satisfied with its own response or needs the supervisor to clarify something from the user"
                    "'rag' when agent is supposed to retrieve information from existing uploaded resources"

    )
    reason: str = Field(
        description="Detailed justification for the routing decision, explaining the rationale behind selecting the particular specialist agent and how this advances the task towards completion."
    )

def orchestrator_node(state: MessagesState) -> Optional[Command[Literal["general", "researcher", "coder", "supervisor", "rag"]]]:

    system_prompt = (f'''
        Current time: {current_time}
        You are an Orchestrator Node responsible for managing a workflow across multiple specialized agents: General, Researcher, and Coder.
        Your primary role is to direct the task through the most efficient path by choosing the right agent at the right time. Your decisions must be based on the current progress and specific needs of the task. Create an effective, minimal-step workflow that uses each agent's strengths wisely, resulting in a clear, correct, and complete solution.

        **Agent Descriptions**:
        1) General:
            - Access to general purpose tools and APIs to 
            - Receives a task list for which tools can be used and information retrieved accordingly
            - Ensure the task-list is specific, well-scoped, and actionable before passing onto the general agent
            - Tasks capable:
                -> General web search
                -> Sending/Reading Emails
                -> Google Calendar updates
                -> Flight Info Retrieval
                -> Google Maps directions & nearby lookups

        2) Researcher:
            - Gathers accurate, factual and relevant information.
            - Conducts fact-finding or background exploration needed for solving the task.
            - Provides context or data that supports downstream processing.
            - Focused on rigor and scientific methodology
            - Tasks capable:
                -> Wikipedia search
                -> Pubmed search
                -> Arxiv search

        3) Coder:
            - Handles technical tasks like writing code, building algorithms, or performing calculations.
            - Converts well-defined and well-researched instructions into executable solutions.
            - Translating specific, well-researched instructions into code.
            - Writing functions, scripts, or notebooks to solve a defined problem.
        
        4) Supervisor:
            - Handles control to supervisor for validation of output
            - Provide a step by step blueprint of steps taken and what tools used.
            - Collate a point by point final output which can be used by supervisor to generate an accurate outcome for the user
        
        5) RAG:
            - It is the retrieval-augmented generation agent
            - Only to be used when the user asks questions regarding an uploaded resource.
            
        **Your Responsibilities**:
        1) Analyze the user's request and any agent responses for clarity, completeness, and alignment with the goal.
        2) Route the task to the most suitable agent at each stage to ensure progress toward a high-quality, complete solution.
        3) Always start by considering the Prompt Enhancer unless the prompt is already clear, structured, and actionable.
        4) Avoid redundancy: Do not assign the same agent unless a new need arises.
        5) Maintain efficiency: Progress the task toward resolution with the fewest, most effective steps.
        6) Conclude the workflow only when the solution fully satisfies the user's request.
        7) In case no tools are required and question can be sufficiently answered by you, then do so and send it to validator/supervisor
    ''')

    claude_llm = ChatAnthropic(
        model="claude-3-5-sonnet-20241022",
        temperature=1
    )

    messages = [
                   {"role": "system", "content": system_prompt},
               ] + state["messages"]

    response = claude_llm.with_structured_output(Orchestrator).invoke(messages)

    goto = response.next
    reason = response.reason

    print(f"--- Orchestrator -> {goto.upper()} ---")

    return Command(
        update={
            "messages": [
                HumanMessage(content=reason, name = "orchestrator"),
            ]
        },
        goto=goto
    )
